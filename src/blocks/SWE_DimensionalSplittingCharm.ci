module SWE_DimensionalSplittingCharm {
	//include "types/BlockConnectInterface.hh";
	include "types/Boundary.hh";
	include "scenarios/SWE_Scenario.hh";
	include "tools/Float2DNative.hh";

	message copyLayer {
		Boundary boundary;
		bool containsBathymetry;
		float b[];
		float h[];
		float hu[];
		float hv[];
		float timestep;
	};

	array [1D] SWE_DimensionalSplittingCharm {
		entry SWE_DimensionalSplittingCharm(int nx, int ny, float dy, float dx, float originX, float originY, int posX, int posY,
							BoundaryType boundaries[4], std::string outputFilename, std::string bathymetryFile, std::string displacementFile,bool localTimestepping);

		entry void compute() {
		    if(localTimestepping){

                //set up max possible timestep in beginning of execution
                serial{
                     computeMaxTimestep( 0.01,0.4);
                     CkCallback cb(CkReductionTarget(SWE_DimensionalSplittingCharm, reduceWaveSpeed), thisProxy);
                     contribute(sizeof(float), &maxTimestep, CkReduction::min_float, cb);
                 }
                 when reductionTrigger()
                 serial {
                    maxTimestepLocal = maxTimestep;
                    CkPrintf("Reduced local Timestep %f\n", maxTimestepLocal);
                 }
            }
		    serial {


				// Start the wall clock
				clock_gettime(CLOCK_MONOTONIC, &startTime);
			}
			while(currentCheckpoint < checkpointCount) {
				serial {
					sendCopyLayers(true);
					setGhostLayer();
				}
				overlap {
					when receiveGhostLeft(copyLayer *msg)
						if (!msg->isDummy) {
							serial { processCopyLayer(msg); }
						}
					when receiveGhostRight(copyLayer *msg)
						if (!msg->isDummy) {
							serial { processCopyLayer(msg); }
						}
					when receiveGhostBottom(copyLayer *msg)
						if (!msg->isDummy) {
							serial { processCopyLayer(msg); }
						}
					when receiveGhostTop(copyLayer *msg)
						if (!msg->isDummy) {
							serial { processCopyLayer(msg); }
						}
				}
				serial {
				     checkAllGhostlayers(); // after receiving all Ghostlayers we can processes them
					// The xSweep will trigger the reduction and accumulate compute time
					if(allGhostlayersInSync()){
					    xSweep();
					}
				}
				if(!localTimestepping){
                    when reductionTrigger()
				    serial{
				    }
				}
				serial {
					// Complete iteration
                    if(allGhostlayersInSync()){
					    ySweep();
					    updateUnknowns(maxTimestep);
                    }

                    if(!localTimestepping || hasMaxLocalTimestep()){

                        // Once the simulation state progressed one iteration, increase the simulation time accordingly
                        currentSimulationTime +=localTimestepping?maxTimestepLocal:maxTimestep;
                        // If a checkpoint was reached after the last step, write current state
                        if (currentSimulationTime >= checkpointInstantOfTime[currentCheckpoint]) {
                            // Exclude I/O from the time measurement, therefore accumulate now
                            clock_gettime(CLOCK_MONOTONIC, &endTime);
                            wallTime += (endTime.tv_sec - startTime.tv_sec);
                            wallTime += (float) (endTime.tv_nsec - startTime.tv_nsec) / 1E9;

                            if(thisIndex == 0) {
                                CkPrintf("Write timestep (%fs)\n", currentSimulationTime);
                            }
                            writeTimestep();
                            currentCheckpoint++;

                            // Restart wall clock
                            clock_gettime(CLOCK_MONOTONIC, &startTime);
                        }

                        // If there is an iteration to go, propagate copy layers anew
                        if (currentSimulationTime < simulationDuration) {
                            clock_gettime(CLOCK_MONOTONIC, &commTime);
                            sendCopyLayers(false);
                            setGhostLayer();
                            clock_gettime(CLOCK_MONOTONIC, &endTime);
                                communicationTime += (endTime.tv_sec - commTime.tv_sec);
                                communicationTime += (float) (endTime.tv_nsec - commTime.tv_nsec) / 1E9;
                        } else {
                            // Accumulate wall time
                            clock_gettime(CLOCK_MONOTONIC, &endTime);
                            wallTime += (endTime.tv_sec - startTime.tv_sec);
                            wallTime += (float) (endTime.tv_nsec - startTime.tv_nsec) / 1E9;

                                //	CkPrintf("Rank %i : Flops(Total): %fGFLOPS:\n", thisIndex,((float)flopCounter)*CkNumPes()/(wallTime*1000000000));
                            CkPrintf("Rank %i : Compute Time (CPU): %fs - (WALL): %fs | Total Time (Wall): %fs\n", thisIndex, computeTime, computeTimeWall, wallTime);

                            mainProxy.done(thisIndex,flopCounter,communicationTime,wallTime,reductionTime);
                        }
					}
				}
			}
		};

		// SDAG entry methods
		entry void receiveGhostLeft(copyLayer *msg);
		entry void receiveGhostRight(copyLayer *msg);
		entry void receiveGhostBottom(copyLayer *msg);
		entry void receiveGhostTop(copyLayer *msg);

		entry void reductionTrigger();
        entry [reductiontarget] void printFlops(double flop);
		// entry methods
		entry [reductiontarget] void reduceWaveSpeed(float maxWaveSpeed);
	};
};
